{
  "language": "Solidity",
  "sources": {
    "contracts/BfsContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"fhevm/lib/TFHE.sol\";\n\n\n//okay here you have already done the encryption portion so that's alright\n//now you got to do the second step of the algorithm \n//for this you need to take the values (encrypted values from the user and store them in your matrix)\n//so you will get the value from the user encrypted value and i and you got to make that value the encrypted value\n//and then return the value to the user\n\ncontract BfsContract {\n    uint8[][] public adjMatrix;\n    euint8 [100][] public encrypted_matrix;\n    euint8 public value;\n    int[] public distance;\n    uint8 public sum=0;\n    uint8 alpha;\n    euint8 temp;\n    uint8 r;\n    \n\n    function set_default (bytes calldata  def,uint8 rows,uint8 cols) public{\n         value=TFHE.asEuint8(def);\n        for (uint i = 0; i < rows; i++) {\n            for (uint j = 0; j < cols; j++) {\n                encrypted_matrix[i][j] = value;\n            }\n        }\n       \n    \n    }\n    function set_alpha (uint8 y) public{\n       \n       alpha=y;\n    \n    }\n    function setrows (uint8 u) public{\n       \n       r=u;\n    \n    }\n\n\n    function set_value (bytes calldata v,uint i) public{\n       encrypted_matrix[i][i]=TFHE.asEuint8(v);\n    }\n\n     function set_value_i (bytes calldata v,uint i,uint j) public{\n       encrypted_matrix[i][j]=TFHE.asEuint8(v);\n    }\n\n\n\n    \n    int[]  distances = new int[](r);\n    function bfs(uint source) public   returns(int [] memory )   {\n        uint numNodes =r;\n        \n        for (uint i = 0; i < numNodes; i++) {\n            distances[i] = -1; // Initialize distances to -1 (unreachable)\n        }\n\n        distances[source] = 0; // Distance from source to itself is 0\n        uint[] memory queue = new uint[](numNodes);\n        uint front = 0;\n        uint rear = 0;\n\n        queue[rear++] = source;\n\n        while (front < rear) {\n            uint currentNode = queue[front++];\n\n            for (uint neighbor = 0; neighbor < numNodes; neighbor++) {\n                if (TFHE.decrypt(TFHE.eq(encrypted_matrix[currentNode][neighbor],value)) && distances[neighbor] == -1) {\n                    distances[neighbor] = int(distances[currentNode]) + 1;\n                    queue[rear++] = neighbor;\n                }\n            }\n        }\n        return(distances);\n    }\n\n\n   function calculating(uint source) public   {\n    for (uint j = 0; j < distances.length; j++) {\n        // int r=distances[j];\n        uint8 s = 2;\n        for(int i=1;i<distances[j];i++){\n            s=s*2;\n        }\n        \n    //    sum+=alpha+((encrypted_matrix[j][j]-a)/s)*encrypted_matrix[source][j];\n    euint8 a=TFHE.asEuint8(9);\n    euint8 d=TFHE.asEuint8(1/s);\n    \n    euint8 t1=TFHE.mul(TFHE.add(encrypted_matrix[j][j],a),d);\n    euint8 t2=TFHE.mul(t1,encrypted_matrix[source][j]);\n    euint8 k =TFHE.add(t2,TFHE.asEuint8(8));\n    temp=TFHE.add(temp,k);\n    \n    } \n    temp=TFHE.add(TFHE.asEuint8(alpha),temp);\n    sum=TFHE.decrypt(temp);\n}\n\n    function show_cal() public view returns(uint8){\n        return(sum);\n    } \n\n    function query_distance_matrix(uint  i) public view returns(int){\n        return(distances[i]);\n    }\n\n\n\n}\n"
    },
    "fhevm/lib/Impl.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity ^0.8.20;\n\nimport \"./TFHE.sol\";\n\ninterface FhevmLib {\n    function fheAdd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheSub(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheMul(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheDiv(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheRem(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheBitAnd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheBitOr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheBitXor(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheShl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheShr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheEq(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheNe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheGe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheGt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheLe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheLt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheMin(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheMax(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheNeg(uint256 ct) external pure returns (uint256 result);\n\n    function fheNot(uint256 ct) external pure returns (uint256 result);\n\n    function reencrypt(uint256 ct, uint256 publicKey) external view returns (bytes memory);\n\n    function fhePubKey(bytes1 fromLib) external view returns (bytes memory result);\n\n    function verifyCiphertext(bytes memory input) external pure returns (uint256 result);\n\n    function cast(uint256 ct, bytes1 toType) external pure returns (uint256 result);\n\n    function trivialEncrypt(uint256 ct, bytes1 toType) external pure returns (uint256 result);\n\n    function decrypt(uint256 ct) external view returns (uint256 result);\n\n    function fheIfThenElse(uint256 control, uint256 ifTrue, uint256 ifFalse) external pure returns (uint256 result);\n\n    function fheRand(bytes1 randType) external view returns (uint256 result);\n\n    function fheRandBounded(uint256 upperBound, bytes1 randType) external view returns (uint256 result);\n}\n\naddress constant EXT_TFHE_LIBRARY = address(0x000000000000000000000000000000000000005d);\n\nlibrary Impl {\n    // 32 bytes for the 'byte' type header + 48 bytes for the NaCl anonymous\n    // box overhead + 4 bytes for the plaintext value.\n    uint256 constant reencryptedSize = 32 + 48 + 4;\n\n    // 32 bytes for the 'byte' header + 16553 bytes of key data.\n    uint256 constant fhePubKeySize = 32 + 16553;\n\n    function add(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheAdd(lhs, rhs, scalarByte);\n    }\n\n    function sub(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheSub(lhs, rhs, scalarByte);\n    }\n\n    function mul(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheMul(lhs, rhs, scalarByte);\n    }\n\n    function div(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\n        bytes1 scalarByte = 0x01;\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheDiv(lhs, rhs, scalarByte);\n    }\n\n    function rem(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\n        bytes1 scalarByte = 0x01;\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheRem(lhs, rhs, scalarByte);\n    }\n\n    function and(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\n        bytes1 scalarByte = 0x00;\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheBitAnd(lhs, rhs, scalarByte);\n    }\n\n    function or(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\n        bytes1 scalarByte = 0x00;\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheBitOr(lhs, rhs, scalarByte);\n    }\n\n    function xor(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\n        bytes1 scalarByte = 0x00;\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheBitXor(lhs, rhs, scalarByte);\n    }\n\n    function shl(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheShl(lhs, rhs, scalarByte);\n    }\n\n    function shr(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheShr(lhs, rhs, scalarByte);\n    }\n\n    function eq(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheEq(lhs, rhs, scalarByte);\n    }\n\n    function ne(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheNe(lhs, rhs, scalarByte);\n    }\n\n    function ge(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheGe(lhs, rhs, scalarByte);\n    }\n\n    function gt(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheGt(lhs, rhs, scalarByte);\n    }\n\n    function le(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheLe(lhs, rhs, scalarByte);\n    }\n\n    function lt(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheLt(lhs, rhs, scalarByte);\n    }\n\n    function min(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheMin(lhs, rhs, scalarByte);\n    }\n\n    function max(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheMax(lhs, rhs, scalarByte);\n    }\n\n    function neg(uint256 ct) internal pure returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheNeg(ct);\n    }\n\n    function not(uint256 ct) internal pure returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheNot(ct);\n    }\n\n    // If 'control's value is 'true', the result has the same value as 'ifTrue'.\n    // If 'control's value is 'false', the result has the same value as 'ifFalse'.\n    function cmux(uint256 control, uint256 ifTrue, uint256 ifFalse) internal pure returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheIfThenElse(control, ifTrue, ifFalse);\n    }\n\n    // We do assembly here because ordinary call will emit extcodesize check which is zero for our precompiles\n    // and revert the transaction because we don't return any data for this precompile method\n    function optReq(uint256 ciphertext) internal view {\n        bytes memory input = abi.encodeWithSignature(\"optimisticRequire(uint256)\", ciphertext);\n        uint256 inputLen = input.length;\n\n        // Call the optimistic require method in precompile.\n        address precompile = EXT_TFHE_LIBRARY;\n        assembly {\n            if iszero(staticcall(gas(), precompile, add(input, 32), inputLen, 0, 0)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    function reencrypt(uint256 ciphertext, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\n        return FhevmLib(address(EXT_TFHE_LIBRARY)).reencrypt(ciphertext, uint256(publicKey));\n    }\n\n    function fhePubKey() internal view returns (bytes memory key) {\n        // Set a byte value of 1 to signal the call comes from the library.\n        key = FhevmLib(address(EXT_TFHE_LIBRARY)).fhePubKey(bytes1(0x01));\n    }\n\n    function verify(bytes memory _ciphertextBytes, uint8 _toType) internal pure returns (uint256 result) {\n        bytes memory input = bytes.concat(_ciphertextBytes, bytes1(_toType));\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).verifyCiphertext(input);\n    }\n\n    function cast(uint256 ciphertext, uint8 toType) internal pure returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).cast(ciphertext, bytes1(toType));\n    }\n\n    function trivialEncrypt(uint256 value, uint8 toType) internal pure returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).trivialEncrypt(value, bytes1(toType));\n    }\n\n    function decrypt(uint256 ciphertext) internal view returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).decrypt(ciphertext);\n    }\n\n    function rand(uint8 randType) internal view returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheRand(bytes1(randType));\n    }\n\n    function randBounded(uint256 upperBound, uint8 randType) internal view returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheRandBounded(upperBound, bytes1(randType));\n    }\n}\n"
    },
    "fhevm/lib/TFHE.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity ^0.8.20;\n\ntype ebool is uint256;\ntype euint8 is uint256;\ntype euint16 is uint256;\ntype euint32 is uint256;\n\nlibrary Common {\n    // Values used to communicate types to the runtime.\n    uint8 internal constant ebool_t = 0;\n    uint8 internal constant euint8_t = 0;\n    uint8 internal constant euint16_t = 1;\n    uint8 internal constant euint32_t = 2;\n}\n\nimport \"./Impl.sol\";\n\nlibrary TFHE {\n    euint8 constant NIL8 = euint8.wrap(0);\n    euint16 constant NIL16 = euint16.wrap(0);\n    euint32 constant NIL32 = euint32.wrap(0);\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint8 v) internal pure returns (bool) {\n        return euint8.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint16 v) internal pure returns (bool) {\n        return euint16.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint32 v) internal pure returns (bool) {\n        return euint32.unwrap(v) != 0;\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b)));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b)));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint8 a, euint8 b) internal pure returns (euint8) {\n        euint8 aEnc = asEuint8(a);\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.div(euint8.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b))));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b))));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b))));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b)));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint16 a, euint16 b) internal pure returns (euint16) {\n        euint16 aEnc = asEuint16(a);\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.div(euint16.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b)));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint32 a, euint32 b) internal pure returns (euint32) {\n        euint32 aEnc = asEuint32(a);\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.div(euint32.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, uint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, uint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, uint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, uint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function cmux(ebool control, euint8 a, euint8 b) internal pure returns (euint8) {\n        return euint8.wrap(Impl.cmux(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function cmux(ebool control, euint16 a, euint16 b) internal pure returns (euint16) {\n        return euint16.wrap(Impl.cmux(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function cmux(ebool control, euint32 a, euint32 b) internal pure returns (euint32) {\n        return euint32.wrap(Impl.cmux(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\n    }\n\n    // Cast an encrypted integer from euint16 to euint8.\n    function asEuint8(euint16 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint8.\n    function asEuint8(euint32 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint8 to ebool.\n    function asEbool(euint8 value) internal pure returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Convert a serialized 'ciphertext' to an encrypted boolean.\n    function asEbool(bytes memory ciphertext) internal pure returns (ebool) {\n        return asEbool(asEuint8(ciphertext));\n    }\n\n    // Convert a plaintext boolean to an encrypted boolean.\n    function asEbool(bool value) internal pure returns (ebool) {\n        if (value) {\n            return asEbool(asEuint8(1));\n        } else {\n            return asEbool(asEuint8(0));\n        }\n    }\n\n    // Converts an 'ebool' to an 'euint8'.\n    function asEuint8(ebool b) internal pure returns (euint8) {\n        return euint8.wrap(ebool.unwrap(b));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(ebool a, ebool b) internal pure returns (ebool) {\n        return asEbool(and(asEuint8(a), asEuint8(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(ebool a, ebool b) internal pure returns (ebool) {\n        return asEbool(or(asEuint8(a), asEuint8(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(ebool a, ebool b) internal pure returns (ebool) {\n        return asEbool(xor(asEuint8(a), asEuint8(b)));\n    }\n\n    function not(ebool a) internal pure returns (ebool) {\n        return asEbool(and(not(asEuint8(a)), asEuint8(1)));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function cmux(ebool cond, ebool a, ebool b) internal pure returns (ebool) {\n        return asEbool(cmux(cond, asEuint8(a), asEuint8(b)));\n    }\n\n    // Cast an encrypted integer from euint8 to euint16.\n    function asEuint16(euint8 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint16.\n    function asEuint16(euint32 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint16 to ebool.\n    function asEbool(euint16 value) internal pure returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint16'.\n    function asEuint16(ebool b) internal pure returns (euint16) {\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint32.\n    function asEuint32(euint8 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint32.\n    function asEuint32(euint16 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint32 to ebool.\n    function asEbool(euint32 value) internal pure returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint32'.\n    function asEuint32(ebool b) internal pure returns (euint32) {\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), Common.euint32_t));\n    }\n\n    function neg(euint8 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\n    }\n\n    function not(euint8 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\n    }\n\n    function neg(euint16 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\n    }\n\n    function not(euint16 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\n    }\n\n    function neg(euint32 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\n    }\n\n    function not(euint32 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\n    }\n\n    // Convert a serialized 'ciphertext' to an encrypted euint8 integer.\n    function asEuint8(bytes memory ciphertext) internal pure returns (euint8) {\n        return euint8.wrap(Impl.verify(ciphertext, Common.euint8_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint8 integer.\n    function asEuint8(uint256 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.euint8_t));\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // Return a serialized euint8 ciphertext.\n    function reencrypt(euint8 value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\n        return Impl.reencrypt(euint8.unwrap(value), publicKey);\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\n    // Return a serialized euint8 ciphertext.\n    function reencrypt(\n        euint8 value,\n        bytes32 publicKey,\n        uint8 defaultValue\n    ) internal view returns (bytes memory reencrypted) {\n        if (euint8.unwrap(value) != 0) {\n            return Impl.reencrypt(euint8.unwrap(value), publicKey);\n        } else {\n            return Impl.reencrypt(euint8.unwrap(asEuint8(defaultValue)), publicKey);\n        }\n    }\n\n    // Decrypts the encrypted 'value'.\n    function decrypt(euint8 value) internal view returns (uint8) {\n        return uint8(Impl.decrypt(euint8.unwrap(value)));\n    }\n\n    // Convert a serialized 'ciphertext' to an encrypted euint16 integer.\n    function asEuint16(bytes memory ciphertext) internal pure returns (euint16) {\n        return euint16.wrap(Impl.verify(ciphertext, Common.euint16_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint16 integer.\n    function asEuint16(uint256 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.euint16_t));\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // Return a serialized euint16 ciphertext.\n    function reencrypt(euint16 value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\n        return Impl.reencrypt(euint16.unwrap(value), publicKey);\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\n    // Return a serialized euint16 ciphertext.\n    function reencrypt(\n        euint16 value,\n        bytes32 publicKey,\n        uint16 defaultValue\n    ) internal view returns (bytes memory reencrypted) {\n        if (euint16.unwrap(value) != 0) {\n            return Impl.reencrypt(euint16.unwrap(value), publicKey);\n        } else {\n            return Impl.reencrypt(euint16.unwrap(asEuint16(defaultValue)), publicKey);\n        }\n    }\n\n    // Decrypts the encrypted 'value'.\n    function decrypt(euint16 value) internal view returns (uint16) {\n        return uint16(Impl.decrypt(euint16.unwrap(value)));\n    }\n\n    // Convert a serialized 'ciphertext' to an encrypted euint32 integer.\n    function asEuint32(bytes memory ciphertext) internal pure returns (euint32) {\n        return euint32.wrap(Impl.verify(ciphertext, Common.euint32_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint32 integer.\n    function asEuint32(uint256 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.euint32_t));\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // Return a serialized euint32 ciphertext.\n    function reencrypt(euint32 value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\n        return Impl.reencrypt(euint32.unwrap(value), publicKey);\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\n    // Return a serialized euint32 ciphertext.\n    function reencrypt(\n        euint32 value,\n        bytes32 publicKey,\n        uint32 defaultValue\n    ) internal view returns (bytes memory reencrypted) {\n        if (euint32.unwrap(value) != 0) {\n            return Impl.reencrypt(euint32.unwrap(value), publicKey);\n        } else {\n            return Impl.reencrypt(euint32.unwrap(asEuint32(defaultValue)), publicKey);\n        }\n    }\n\n    // Decrypts the encrypted 'value'.\n    function decrypt(euint32 value) internal view returns (uint32) {\n        return uint32(Impl.decrypt(euint32.unwrap(value)));\n    }\n\n    // Optimistically require that 'b' is true.\n    //\n    // This function does not evaluate 'b' at the time of the call.\n    // Instead, it accumulates all optimistic requires and evaluates a single combined\n    // require at the end of the transaction. A side effect of this mechanism\n    // is that a method call with a failed optimistic require will always incur the full\n    // gas cost, as if all optimistic requires were true. Yet, the transaction will be\n    // reverted at the end if any of the optimisic requires were false.\n    //\n    // Exceptions to above rule are reencryptions and decryptions via\n    // TFHE.reencrypt() and TFHE.decrypt(), respectively. If either of them\n    // are encountered and if optimistic requires have been used before in the\n    // txn, the optimisic requires will be immediately evaluated. Rationale is\n    // that we want to avoid decrypting or reencrypting a value if the txn is about\n    // to fail and be reverted anyway at the end. Checking immediately and reverting on the spot\n    // would avoid unnecessary decryptions.\n    //\n    // The benefit of optimistic requires is that they are faster than non-optimistic ones,\n    // because there is a single call to the decryption oracle per transaction, irrespective\n    // of how many optimistic requires were used.\n    function optReq(ebool b) internal view {\n        Impl.optReq(ebool.unwrap(b));\n    }\n\n    // Decrypts the encrypted 'value'.\n    function decrypt(ebool value) internal view returns (bool) {\n        return (Impl.decrypt(ebool.unwrap(value)) != 0);\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // Return a serialized euint8 value.\n    function reencrypt(ebool value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\n        return Impl.reencrypt(ebool.unwrap(value), publicKey);\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // Return a serialized euint8 value.\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\n    function reencrypt(\n        ebool value,\n        bytes32 publicKey,\n        bool defaultValue\n    ) internal view returns (bytes memory reencrypted) {\n        if (ebool.unwrap(value) != 0) {\n            return Impl.reencrypt(ebool.unwrap(value), publicKey);\n        } else {\n            return Impl.reencrypt(ebool.unwrap(asEbool(defaultValue)), publicKey);\n        }\n    }\n\n    // Returns the network public FHE key.\n    function fhePubKey() internal view returns (bytes memory) {\n        return Impl.fhePubKey();\n    }\n\n    // Generates a random encrypted 8-bit unsigned integer.\n    // Important: The random integer is generated in the plain! An FHE-based version is coming soon.\n    function randEuint8() internal view returns (euint8) {\n        return euint8.wrap(Impl.rand(Common.euint8_t));\n    }\n\n    // Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    // Important: The random integer is generated in the plain! An FHE-based version is coming soon.\n    function randEuint8(uint8 upperBound) internal view returns (euint8) {\n        return euint8.wrap(Impl.randBounded(upperBound, Common.euint8_t));\n    }\n\n    // Generates a random encrypted 16-bit unsigned integer.\n    // Important: The random integer is generated in the plain! An FHE-based version is coming soon.\n    function randEuint16() internal view returns (euint16) {\n        return euint16.wrap(Impl.rand(Common.euint16_t));\n    }\n\n    // Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    // Important: The random integer is generated in the plain! An FHE-based version is coming soon.\n    function randEuint16(uint16 upperBound) internal view returns (euint16) {\n        return euint16.wrap(Impl.randBounded(upperBound, Common.euint16_t));\n    }\n\n    // Generates a random encrypted 32-bit unsigned integer.\n    // Important: The random integer is generated in the plain! An FHE-based version is coming soon.\n    function randEuint32() internal view returns (euint32) {\n        return euint32.wrap(Impl.rand(Common.euint32_t));\n    }\n\n    // Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    // Important: The random integer is generated in the plain! An FHE-based version is coming soon.\n    function randEuint32(uint32 upperBound) internal view returns (euint32) {\n        return euint32.wrap(Impl.randBounded(upperBound, Common.euint32_t));\n    }\n}\n\nusing {tfheBinaryOperatorAdd8 as +} for euint8 global;\n\nfunction tfheBinaryOperatorAdd8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.add(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorSub8 as -} for euint8 global;\n\nfunction tfheBinaryOperatorSub8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.sub(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorMul8 as *} for euint8 global;\n\nfunction tfheBinaryOperatorMul8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.mul(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorAnd8 as &} for euint8 global;\n\nfunction tfheBinaryOperatorAnd8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.and(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorOr8 as |} for euint8 global;\n\nfunction tfheBinaryOperatorOr8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.or(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorXor8 as ^} for euint8 global;\n\nfunction tfheBinaryOperatorXor8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.xor(lhs, rhs);\n}\n\nusing {tfheUnaryOperatorNeg8 as -} for euint8 global;\n\nfunction tfheUnaryOperatorNeg8(euint8 input) pure returns (euint8) {\n    return TFHE.neg(input);\n}\n\nusing {tfheUnaryOperatorNot8 as ~} for euint8 global;\n\nfunction tfheUnaryOperatorNot8(euint8 input) pure returns (euint8) {\n    return TFHE.not(input);\n}\n\nusing {tfheBinaryOperatorAdd16 as +} for euint16 global;\n\nfunction tfheBinaryOperatorAdd16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.add(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorSub16 as -} for euint16 global;\n\nfunction tfheBinaryOperatorSub16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.sub(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorMul16 as *} for euint16 global;\n\nfunction tfheBinaryOperatorMul16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.mul(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorAnd16 as &} for euint16 global;\n\nfunction tfheBinaryOperatorAnd16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.and(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorOr16 as |} for euint16 global;\n\nfunction tfheBinaryOperatorOr16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.or(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorXor16 as ^} for euint16 global;\n\nfunction tfheBinaryOperatorXor16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.xor(lhs, rhs);\n}\n\nusing {tfheUnaryOperatorNeg16 as -} for euint16 global;\n\nfunction tfheUnaryOperatorNeg16(euint16 input) pure returns (euint16) {\n    return TFHE.neg(input);\n}\n\nusing {tfheUnaryOperatorNot16 as ~} for euint16 global;\n\nfunction tfheUnaryOperatorNot16(euint16 input) pure returns (euint16) {\n    return TFHE.not(input);\n}\n\nusing {tfheBinaryOperatorAdd32 as +} for euint32 global;\n\nfunction tfheBinaryOperatorAdd32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.add(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorSub32 as -} for euint32 global;\n\nfunction tfheBinaryOperatorSub32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.sub(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorMul32 as *} for euint32 global;\n\nfunction tfheBinaryOperatorMul32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.mul(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorAnd32 as &} for euint32 global;\n\nfunction tfheBinaryOperatorAnd32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.and(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorOr32 as |} for euint32 global;\n\nfunction tfheBinaryOperatorOr32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.or(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorXor32 as ^} for euint32 global;\n\nfunction tfheBinaryOperatorXor32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.xor(lhs, rhs);\n}\n\nusing {tfheUnaryOperatorNeg32 as -} for euint32 global;\n\nfunction tfheUnaryOperatorNeg32(euint32 input) pure returns (euint32) {\n    return TFHE.neg(input);\n}\n\nusing {tfheUnaryOperatorNot32 as ~} for euint32 global;\n\nfunction tfheUnaryOperatorNot32(euint32 input) pure returns (euint32) {\n    return TFHE.not(input);\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "evmVersion": "shanghai",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031373134343734383730393636"
      }
    }
  }
}